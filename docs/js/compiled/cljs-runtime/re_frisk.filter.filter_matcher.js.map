{"version":3,"sources":["re_frisk/filter/filter_matcher.cljs"],"mappings":";AAGA,4CAAA,5CAAOA,gGAAYC,EAAEC;AAArB,AACE,OAACC,6CAAEF,EAAEC;;AAEP,qDAAA,rDAAOE,kHAAqBH,EAAEC;AAA9B,AACE,SAAK,OAASA,oBAAG,AAACG,kCAAiBH,EAAED;;AAEvC,4CAAA,5CAAOK,gGAAYL,EAAEC;AAArB,AACE,OAACK,+BAAc,4CAAKL,GAAGD;;AAEzB,6CAAA,7CAAOO,kGAAaP,EAAEC;AAAtB,AACE,GAAM,4BAAA,5BAACO,0BAAUR;AAAS,OAACD,0CAAW,AAAA,kFAAOC,GAAGC;;AAAhD,GACM,4BAAA,5BAACO,0BAAUR;AAAkB,OAACG,mDAAoB,AAAA,qGAAgBH,GAAGC;;AAD3E,GAEM,4BAAA,5BAACO,0BAAUR;AAAS,OAACK,0CAAW,AAAA,kFAAOL,GAAGC;;AAFhD,AAGY,MAAO,KAAAQ,MAAW,CAAA,4EAAqCT;;;;;;AAErE,uCAAA,vCAAMU,sFAAOC,OAAOC;;AAApB,AACE,GAAM,AAACC,uBAAOF;AAAd;;AAAA,GACM,AAACE,uBAAOD;AADd;;AAAA,GAEM,qEAAA,rEAACV,6CAAE,AAACY,gBAAMH;AAAW,OAACJ,2CAAY,AAACQ,gBAAMJ,QAAQ,AAACK,eAAKJ;;AAF7D,AAGY,GAAI,AAACL,2CAAY,AAACQ,gBAAMJ,QAAQ,AAACI,gBAAMH;AACrC,eAAO,AAACK,eAAKN;eAAQ,AAACM,eAAKL;;;;;AAC3B,eAAOD;eAAO,AAACM,eAAKL","names":["re-frisk.filter.filter-matcher/match-expr","f","p","cljs.core._EQ_","re-frisk.filter.filter-matcher/match-string-prefix","clojure.string/starts-with?","re-frisk.filter.filter-matcher/match-free","clojure.string/includes?","re-frisk.filter.filter-matcher/match-value","cljs.core/contains?","js/Error","re-frisk.filter.filter-matcher/match","filter","path","cljs.core/empty?","cljs.core/count","cljs.core/first","cljs.core/last","cljs.core/rest"],"sourcesContent":["(ns re-frisk.filter.filter-matcher\n  (:require [clojure.string :as str]))\n\n(defn- match-expr [f p]\n  (= f p))\n\n(defn- match-string-prefix [f p]\n  (and (string? p) (str/starts-with? p f)))\n\n(defn- match-free [f p]\n  (str/includes? (str p) f))\n\n(defn- match-value [f p]\n  (cond (contains? f :expr) (match-expr (:expr f) p)\n        (contains? f :string-prefix) (match-string-prefix (:string-prefix f) p)\n        (contains? f :free) (match-free (:free f) p)\n        :else (throw (js/Error. (str \"Unknown kind of filter-path: \" f)))))\n\n(defn match [filter path]\n  (cond (empty? filter) nil\n        (empty? path) nil\n        (= (count filter) 1) (match-value (first filter) (last path))\n        :else (if (match-value (first filter) (first path))\n                (recur (rest filter) (rest path))\n                (recur filter (rest path)))))\n"]}