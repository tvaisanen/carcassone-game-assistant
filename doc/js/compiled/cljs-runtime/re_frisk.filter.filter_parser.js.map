{"version":3,"sources":["re_frisk/filter/filter_parser.cljs"],"mappings":";AAMA,yCAAA,zCAAOA,0FAAUC;AAAjB,AACE,IAAAC,WAAM,AAACE,yCAAUH;AAAjB,AAAA,GAAA,AAAAE,6CAAA,KAAAD;AAAA,AAAA;;AAAA,AAEE,OAACG,eAAK,AAACC,yCAAUL,KAAK,CAACD,uEAAAA,4EAAAA,PAASC,wDAAAA;;;;AAGpC,yDAAA,zDAAOM,0HAAcC;AAArB,AACE,IAAMC,KAAG,AAACC,qFAAwBF;IAC5BG,MAAI,AAACC,qDAAYH;IACjBI,OAAK,AAACC,kDAAS,AAACd,uCAASS;AAF/B,AAAA,kDAAA,sDAAA,JAGQE,0DAAUE;;AAEpB,+CAAA,/CAAOE,sGAAgBP;AAAvB,AACE,IAAAQ,aAAoB,qDAAA,MAAA,3DAACG,mDAAUX;aAA/B,AAAAS,4CAAAD,WAAA,IAAA,pEAAOE;WAAP,AAAAD,4CAAAD,WAAA,IAAA,lEAAcH;AAAd,AAAA,kDAAA,kDAAA,2CAAA,mEAAA,fACeK,qEAAc,iBAAAE,mBAAIP;AAAJ,AAAA,oBAAAO;AAAAA;;AAAA;;;;AAE/B,mDAAA,nDAAOC,8GAAoBb;AAA3B,AACE,IAAA,AACE,IAAAe,aAAiC,AAAChB,uDAAaC;IAA/Ce,iBAAA,AAAAC,4BAAAD;UAAAA,NAA4BG;UAA5B,AAAAD,4CAAAF,eAAA,jEAAcZ;WAAd,AAAAc,4CAAAF,eAAA,lEAAkBV;AAAlB,AAAA,kDAAA,kDAAA,2CAAA,gEAAA,ZACeF,kEAAWE;gBAF5B,QAAAS,JAGkBK;AAHlB,AAGoB,OAACZ,6CAAeP;;AAEtC,qDAAA,rDAAOoB,kHAAsBpB;AAA7B,AACE,IAAA,AACE,IAAAsB,aAA4B,AAACvB,uDAAaC;IAA1CsB,iBAAA,AAAAN,4BAAAM;UAAA,AAAAL,4CAAAK,eAAA,jEAAOnB;WAAP,AAAAc,4CAAAK,eAAA,lEAAgBjB;AAAhB,AAAA,kDAAA,kDAAA,2CAAA,gEAAA,ZACeF,kEAAWE;gBAF5B,QAAAgB,JAGkBF;AAHlB,AAMI,IAAAI,aAAoB,qDAAA,MAAA,3DAACZ,mDAAUX;aAA/B,AAAAS,4CAAAc,WAAA,IAAA,pEAAOb;WAAP,AAAAD,4CAAAc,WAAA,IAAA,lEAAclB;IACRK,aAAO,8BAAA,MAAA,pCAACc,uBAAYd;AAD1B,AAAA,kDAAA,kDAAA,2CAAA,0FAAA,nBAEwBA,yEAAc,iBAAAE,mBAAIP;AAAJ,AAAA,oBAAAO;AAAAA;;AAAA;;;;AAE5C,2CAAA,3CAAOa,8FAAYzB;AAAnB,AACE,IAAA0B,WAAM,AAACC,gBAAM3B;AAAb,AAAA,QAAA0B;KAAA;KAAA;KAAA;KAAA;KAAA;KAAA;KAAA;AAEiC,OAACb,iDAAmBb;;;KAFrD;AAIO,OAACoB,mDAAqBpB;;;;AAE3B,OAACO,6CAAeP;;;;AAEpB,mDAAA,nDAAO4B,8GAAQ5B;AAAf,AACE,IAAMA,QAAE,AAAC6B,oBAAS7B;IAEZA,QAAE,6BAAA,aAAA,1CAACwB,uBAAYxB;AAFrB,AAGE,GAAI,mDAAA,nDAACL,6CAAEK;AAAP,AAAA;;AACI,IAAA8B,aAA4B,AAACL,yCAAWzB;IAAxC8B,iBAAA,AAAAd,4BAAAc;UAAA,AAAAb,4CAAAa,eAAA,jEAAO3B;WAAP,AAAAc,4CAAAa,eAAA,lEAAgBzB;AAAhB,AACE,OAACR,eAAKM,IAAI,CAACyB,iFAAAA,uFAAAA,RAAOvB,mEAAAA;;;AAE5B,sCAAA,tCAAM0B,oFAAO/B;AAAb,AACE,oDAAA,7CAACgC,8EAAQ,AAACJ,iDAAO5B","names":["re-frisk.filter.filter-parser/read-all","rdr","G__38946","cljs.core._EQ_","cljs.tools.reader.reader-types/peek-char","cljs.core/cons","cljs.tools.reader.reader-types/read-char","re-frisk.filter.filter-parser/read-string'","s","sr","cljs.tools.reader.reader_types.string_push_back_reader","val","cljs.tools.reader.read","rest","clojure.string.join","re-frisk.filter.filter-parser/parse-freeform","vec__38949","cljs.core.nth","prefix","clojure.string.split","or__4223__auto__","re-frisk.filter.filter-parser/parse-clojure-expr","e38953","map__38954","cljs.core/--destructure-map","cljs.core.get","foo","_","re-frisk.filter.filter-parser/parse-clojure-string","e38956","map__38961","vec__38958","clojure.string/replace","re-frisk.filter.filter-parser/parse-part","G__38967","cljs.core/first","re-frisk.filter.filter-parser/parse'","clojure.string/trim","map__38968","re-frisk.filter.filter-parser/parse","cljs.core.into"],"sourcesContent":["(ns re-frisk.filter.filter-parser\n  (:require [cljs.tools.reader.reader-types\n             :refer [string-push-back-reader peek-char read-char]]\n            [cljs.tools.reader :as reader]\n            [clojure.string :as str]))\n\n(defn- read-all [rdr]\n  (case (peek-char rdr)\n    nil '()\n    (cons (read-char rdr) (read-all rdr))))\n\n;; like reader/read-string, but returns unread portion of the string too\n(defn- read-string' [s]\n  (let [sr (string-push-back-reader s)\n        val (reader/read sr)\n        rest (str/join (read-all sr))]\n    {:val val :rest rest}))\n\n(defn- parse-freeform [s]\n  (let [[prefix rest] (str/split s #\"\\s+\" 2)]\n    {:val {:free prefix} :rest (or rest \"\")}))\n\n(defn- parse-clojure-expr [s]\n  (try\n    (let [{:keys [val rest] :as foo} (read-string' s)]\n      {:val {:expr val} :rest rest})\n    (catch :default _ (parse-freeform s))))\n\n(defn- parse-clojure-string [s]\n  (try\n    (let [{val :val rest :rest} (read-string' s)]\n      {:val {:expr val} :rest rest})\n    (catch :default _\n      ;; If a string cannot be fully parsed, mark it as \"unfinished\"\n      ;; to do the prefix match later: \"abc will match \"abc\" and \"abcde\"\n      (let [[prefix rest] (str/split s #\"\\s+\" 2)\n            prefix (str/replace prefix #\"^\\\"\" \"\")] ; Kill \" at the beginning\n        {:val {:string-prefix prefix} :rest (or rest \"\")}))))\n\n(defn- parse-part [s]\n  (case (first s)\n    ;; If it looks like a Clojure literal, parse it as such\n    (\"[\" \"(\" \"{\" \"#\" \"\\\\\" \"'\" \":\") (parse-clojure-expr s)\n    ;; If it looks like a string, parse it as a string (relaxed)\n    \"\\\"\" (parse-clojure-string s)\n    ;; Otherwise it's a freeform\n    (parse-freeform s)))\n\n(defn- parse' [s]\n  (let [s (str/trim s)\n        ;; Remove outer [] of the expression, if any\n        s (str/replace s #\"^\\[(.*)\\]$\" \"$1\")]\n    (if (= s \"\") '()\n        (let [{val :val rest :rest} (parse-part s)]\n          (cons val (parse' rest))))))\n\n(defn parse [s]\n  (into [] (parse' s)))\n"]}